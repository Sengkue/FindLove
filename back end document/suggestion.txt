# ๐ Notification System for Love App - PostgreSQL Version

## เบเบณเบญเบฐเบเบดเบเบฒเบ (Description)
เบฅเบฐเบเบปเบ Notification เบชเบณเบฅเบฑเบ Dating App เบเบตเปเบกเบต real-time notifications, countdown timers, เปเบฅเบฐ automatic scheduling เปเบเป PostgreSQL database.

## ๐ เบเบฒเบเบเบดเบเบเบฑเปเบ (Installation)

### 1. เบเบดเบเบเบฑเปเบ PostgreSQL
เปเบซเปเปเบเปเปเบเบงเปเบฒเบกเบต PostgreSQL เบเบดเบเบเบฑเปเบเปเบฅเปเบง เปเบฅเบฐ running เบขเบนเป port 5432

### 2. เบชเปเบฒเบ database
\`\`\`sql
-- เปเบเบปเปเบฒ psql terminal
psql -U postgres

-- เบชเปเบฒเบ database
CREATE DATABASE findlovedb;

-- เบเบงเบเปเบเบดเปเบเบงเปเบฒเบชเปเบฒเบเปเบฅเปเบงเบเป
\l
\`\`\`

### 3. Clone เปเบฅเบฐ setup project
\`\`\`bash
mkdir notification-system
cd notification-system

# Copy เปเบเบฅเปเธเบฑเบเปเบปเบเบเบฒเบ artifact
# เปเบฅเปเบง install dependencies
npm install
\`\`\`

### 4. เบเบงเบเปเบเบดเปเบ .env file
\`\`\`env
NODE_ENV=development
PORT=3000
DB_HOST=localhost
DB_PORT=5432
DB_NAME=findlovedb
DB_USER=postgres
DB_PASS=123
\`\`\`

### 5. เบเบงเบเปเบเบดเปเบเบเบฒเบเปเบเบทเปเบญเบกเบเปเป database
\`\`\`bash
# เบเบปเบเบชเบญเบเปเบเบทเปเบญเบกเบเปเปเปเบเบเบเบปเบ
psql -h localhost -p 5432 -U postgres -d findlovedb
\`\`\`

### 6. Start server (เบเบฐเบชเปเบฒเบ tables เบญเบฑเบเบเบฐเปเบเบกเบฑเบ)
\`\`\`bash
npm run dev
\`\`\`

### 7. เปเบเบตเบเปเบ browser
\`\`\`
http://localhost:3000
\`\`\`

## ๐ง Connection เนเธเบ Direct
เปเบ \`models/index.js\` เปเบเป connection เปเบเบเบเบตเปเปเบเบปเปเบฒเบเปเบญเบเบเบฒเบ:
\`\`\`javascript
const sequelize = new Sequelize('findlovedb', 'postgres', '123', {
  host: 'localhost',
  dialect: 'postgres',
  port: 5432
});
\`\`\`

## ๐ เบเบงเบฒเบกเปเบเบเบเปเบฒเบเบเบฒเบ MySQL

### โ **PostgreSQL เบเปเปเบเบต:**
- **JSON Support** - เปเบเบฑเบเบเปเปเบกเบนเบ JSON เปเบเปเบเบตเบเบงเปเบฒ
- **Performance** - เปเบงเบเบงเปเบฒเบชเบณเบฅเบฑเบ complex queries
- **ENUM Types** - เบฎเบญเบเบฎเบฑเบ ENUM เปเบเปเบเบต
- **Advanced Features** - Array, UUID, Full-text search

### ๐ **เบเบฒเบเบเบฑเบเปเบเปเบเบชเบณเบฅเบฑเบ PostgreSQL:**
- เปเบเป \`pg\` เปเบฅเบฐ \`pg-hstore\` packages
- \`underscored: true\` เบชเบณเบฅเบฑเบ snake_case columns
- Connection pooling เบชเบณเบฅเบฑเบ performance
- Index optimization

## ๐๏ธ Database Tables เบเบตเปเบชเปเบฒเบ:

### 1. **users**
\`\`\`sql
CREATE TABLE users (
  user_id SERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(100) UNIQUE NOT NULL,
  first_name VARCHAR(50) NOT NULL,
  last_name VARCHAR(50) NOT NULL,
  is_active BOOLEAN DEFAULT true,
  socket_id VARCHAR(100),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
\`\`\`

### 2. **notifications**
\`\`\`sql
CREATE TYPE notification_type_enum AS ENUM (
  'timer_warning', 'timer_expired', 'decision_required', 
  'partner_decision', 'match_found', 'message_received'
);

CREATE TYPE related_type_enum AS ENUM (
  'timer', 'conversation', 'match', 'message'
);

CREATE TABLE notifications (
  notification_id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(user_id),
  notification_type notification_type_enum NOT NULL,
  title VARCHAR(200) NOT NULL,
  message TEXT NOT NULL,
  related_id INTEGER,
  related_type related_type_enum,
  is_read BOOLEAN DEFAULT false,
  is_urgent BOOLEAN DEFAULT false,
  scheduled_at TIMESTAMP,
  sent_at TIMESTAMP,
  read_at TIMESTAMP,
  expires_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
\`\`\`

### 3. **conversation_timers**
\`\`\`sql
CREATE TYPE timer_result_enum AS ENUM (
  'both_continue', 'user1_stop', 'user2_stop', 'expired'
);

CREATE TABLE conversation_timers (
  timer_id SERIAL PRIMARY KEY,
  conversation_id INTEGER NOT NULL,
  user1_id INTEGER NOT NULL,
  user2_id INTEGER NOT NULL,
  phase_number INTEGER DEFAULT 1,
  phase_name VARCHAR(50) NOT NULL,
  duration_days INTEGER NOT NULL,
  starts_at TIMESTAMP NOT NULL,
  ends_at TIMESTAMP NOT NULL,
  is_active BOOLEAN DEFAULT true,
  is_completed BOOLEAN DEFAULT false,
  completed_at TIMESTAMP,
  result timer_result_enum,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
\`\`\`

## ๐ PostgreSQL Specific Features เบเบตเปเปเบเป:

### **ENUM Types:**
- เบเบฐเบซเบเบฑเบ storage space
- Data validation เปเบ database level
- Type safety

### **SERIAL:**
- Auto-increment primary keys
- เบเบตเบเบงเปเบฒ AUTO_INCREMENT เบเบญเบ MySQL

### **Timestamps:**
- PostgreSQL เบกเบต timezone support เบเบตเบเบงเปเบฒ
- TIMESTAMP เปเบเบ DATETIME

## ๐จ Troubleshooting

### เบเปเบฒเปเบเบทเปเบญเบกเบเปเป database เบเปเปเปเบเป:
\`\`\`bash
# เบเบงเบเปเบเบดเปเบเบงเปเบฒ PostgreSQL running เบเป
sudo systemctl status postgresql

# เบซเบผเบท เปเบ macOS
brew services list | grep postgresql

# เปเบฅเบตเปเบก PostgreSQL
sudo systemctl start postgresql
# เบซเบผเบท
brew services start postgresql
\`\`\`

### เบเปเบฒ password เบเปเปเบเบทเบ:
\`\`\`sql
-- เปเบ psql เปเบเบฑเบ superuser
ALTER USER postgres PASSWORD '123';
\`\`\`

### เบเปเบฒ permission denied:
\`\`\`bash
# เปเบเปเปเบเปเบ pg_hba.conf
sudo nano /etc/postgresql/14/main/pg_hba.conf

# เปเบเบฑเบ md5 authentication:
local   all             postgres                                md5
\`\`\`

เบฅเบฐเบเบปเบเบเบตเปเบเปเบญเบกเปเบเปเบเบฒเบเบเบฑเบ PostgreSQL เปเบฅเปเบง! ๐โจ// package.json
{
  "name": "notification-system",
  "version": "1.0.0",
  "description": "Test notification system for love app",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "db:migrate": "npx sequelize-cli db:migrate",
    "db:seed": "npx sequelize-cli db:seed:all"
  },
  "dependencies": {
    "express": "^4.18.2",
    "sequelize": "^6.35.2",
    "pg": "^8.11.3",
    "pg-hstore": "^2.3.4",
    "socket.io": "^4.7.4",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "moment": "^2.29.4",
    "node-cron": "^3.0.3"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "sequelize-cli": "^6.6.2"
  }
}

// ==========================================
// .env
NODE_ENV=development
PORT=3000
DB_HOST=localhost
DB_PORT=5432
DB_NAME=findlovedb
DB_USER=postgres
DB_PASS=123

// ==========================================
// config/database.js
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    logging: console.log,
    pool: {
      max: 5,
      min: 0,
      acquire: 30000,
      idle: 10000
    }
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    logging: false,
    pool: {
      max: 10,
      min: 0,
      acquire: 30000,
      idle: 10000
    }
  }
};

// ==========================================
// models/index.js
const { Sequelize } = require('sequelize');

// Direct connection เปเบเบเบเบตเปเปเบเบปเปเบฒเปเบเป
const sequelize = new Sequelize('findlovedb', 'postgres', '123', {
  host: 'localhost',
  dialect: 'postgres',
  port: 5432,
  logging: console.log,
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  },
  define: {
    // เปเบเป snake_case เบชเบณเบฅเบฑเบ column names
    underscored: true,
    // เบเปเปเปเบเบตเปเบก s เปเบเบเบทเป table
    freezeTableName: true
  }
});

// Import models
const User = require('./User')(sequelize, Sequelize.DataTypes);
const Notification = require('./Notification')(sequelize, Sequelize.DataTypes);
const ConversationTimer = require('./ConversationTimer')(sequelize, Sequelize.DataTypes);

// Define associations
User.hasMany(Notification, { foreignKey: 'user_id', as: 'notifications' });
Notification.belongsTo(User, { foreignKey: 'user_id', as: 'user' });

ConversationTimer.hasMany(Notification, { 
  foreignKey: 'related_id', 
  constraints: false,
  scope: { related_type: 'timer' },
  as: 'notifications'
});

const db = {
  sequelize,
  Sequelize,
  User,
  Notification,
  ConversationTimer
};

module.exports = db;

// ==========================================
// models/User.js
module.exports = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    user_id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    username: {
      type: DataTypes.STRING(50),
      allowNull: false,
      unique: true
    },
    email: {
      type: DataTypes.STRING(100),
      allowNull: false,
      unique: true
    },
    first_name: {
      type: DataTypes.STRING(50),
      allowNull: false
    },
    last_name: {
      type: DataTypes.STRING(50),
      allowNull: false
    },
    is_active: {
      type: DataTypes.BOOLEAN,
      defaultValue: true
    },
    socket_id: {
      type: DataTypes.STRING(100),
      allowNull: true
    }
  }, {
    tableName: 'users',
    timestamps: true,
    // PostgreSQL เปเบเป snake_case
    underscored: true
  });

  return User;
};

// ==========================================
// models/Notification.js
module.exports = (sequelize, DataTypes) => {
  const Notification = sequelize.define('Notification', {
    notification_id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    user_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'users',
        key: 'user_id'
      }
    },
    notification_type: {
      type: DataTypes.ENUM(
        'timer_warning', 
        'timer_expired', 
        'decision_required', 
        'partner_decision',
        'match_found',
        'message_received'
      ),
      allowNull: false
    },
    title: {
      type: DataTypes.STRING(200),
      allowNull: false
    },
    message: {
      type: DataTypes.TEXT,
      allowNull: false
    },
    related_id: {
      type: DataTypes.INTEGER,
      allowNull: true
    },
    related_type: {
      type: DataTypes.ENUM('timer', 'conversation', 'match', 'message'),
      allowNull: true
    },
    is_read: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    is_urgent: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    scheduled_at: {
      type: DataTypes.DATE,
      allowNull: true
    },
    sent_at: {
      type: DataTypes.DATE,
      allowNull: true
    },
    read_at: {
      type: DataTypes.DATE,
      allowNull: true
    },
    expires_at: {
      type: DataTypes.DATE,
      allowNull: true
    }
  }, {
    tableName: 'notifications',
    timestamps: true,
    // PostgreSQL เปเบเป snake_case
    underscored: true
  });

  return Notification;
};

// ==========================================
// models/ConversationTimer.js
module.exports = (sequelize, DataTypes) => {
  const ConversationTimer = sequelize.define('ConversationTimer', {
    timer_id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    conversation_id: {
      type: DataTypes.INTEGER,
      allowNull: false
    },
    user1_id: {
      type: DataTypes.INTEGER,
      allowNull: false
    },
    user2_id: {
      type: DataTypes.INTEGER,
      allowNull: false
    },
    phase_number: {
      type: DataTypes.INTEGER,
      allowNull: false,
      defaultValue: 1
    },
    phase_name: {
      type: DataTypes.STRING(50),
      allowNull: false
    },
    duration_days: {
      type: DataTypes.INTEGER,
      allowNull: false
    },
    starts_at: {
      type: DataTypes.DATE,
      allowNull: false
    },
    ends_at: {
      type: DataTypes.DATE,
      allowNull: false
    },
    is_active: {
      type: DataTypes.BOOLEAN,
      defaultValue: true
    },
    is_completed: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    completed_at: {
      type: DataTypes.DATE,
      allowNull: true
    },
    result: {
      type: DataTypes.ENUM('both_continue', 'user1_stop', 'user2_stop', 'expired'),
      allowNull: true
    }
  }, {
    tableName: 'conversation_timers',
    timestamps: true,
    // PostgreSQL เปเบเป snake_case
    underscored: true
  });

  return ConversationTimer;
};

// ==========================================
// services/notificationService.js
const { Notification, User } = require('../models');
const moment = require('moment');

class NotificationService {
  
  // เบชเปเบฒเบ notification เปเปเป
  static async createNotification(data) {
    try {
      const notification = await Notification.create({
        user_id: data.user_id,
        notification_type: data.type,
        title: data.title,
        message: data.message,
        related_id: data.related_id || null,
        related_type: data.related_type || null,
        is_urgent: data.is_urgent || false,
        scheduled_at: data.scheduled_at || new Date(),
        expires_at: data.expires_at || null
      });
      
      console.log(`โ Notification created: ${notification.notification_id}`);
      return notification;
    } catch (error) {
      console.error('โ Error creating notification:', error);
      throw error;
    }
  }

  // เบชเปเบฒเบ timer warning notifications
  static async createTimerWarning(timerId, hoursLeft) {
    try {
      const timer = await ConversationTimer.findByPk(timerId);
      if (!timer) return;

      const notifications = await Promise.all([
        this.createNotification({
          user_id: timer.user1_id,
          type: 'timer_warning',
          title: 'โฐ เปเบงเบฅเบฒเปเบเปเปเบปเบเปเบฅเปเบง!',
          message: `เปเบซเบผเบทเบญ ${hoursLeft} เบเบปเปเบงเปเบกเบเปเบเบเบฒเบเบเบฑเบเบชเบดเบเปเบ! เปเบเบปเปเบฒเบเปเบญเบเบเบฒเบเบชเบทเบเบเปเปเบเป?`,
          related_id: timerId,
          related_type: 'timer',
          is_urgent: hoursLeft <= 3
        }),
        this.createNotification({
          user_id: timer.user2_id,
          type: 'timer_warning',
          title: 'โฐ เปเบงเบฅเบฒเปเบเปเปเบปเบเปเบฅเปเบง!',
          message: `เปเบซเบผเบทเบญ ${hoursLeft} เบเบปเปเบงเปเบกเบเปเบเบเบฒเบเบเบฑเบเบชเบดเบเปเบ! เปเบเบปเปเบฒเบเปเบญเบเบเบฒเบเบชเบทเบเบเปเปเบเป?`,
          related_id: timerId,
          related_type: 'timer',
          is_urgent: hoursLeft <= 3
        })
      ]);

      return notifications;
    } catch (error) {
      console.error('โ Error creating timer warning:', error);
    }
  }

  // เบชเปเบฒเบ decision required notification
  static async createDecisionRequired(timerId) {
    try {
      const timer = await ConversationTimer.findByPk(timerId);
      if (!timer) return;

      const nextPhase = timer.phase_number + 1;
      const nextDuration = this.getNextPhaseDuration(nextPhase);

      const notifications = await Promise.all([
        this.createNotification({
          user_id: timer.user1_id,
          type: 'decision_required',
          title: '๐ เปเบงเบฅเบฒเบเบฑเบเบชเบดเบเปเบ!',
          message: `เปเบฅเบเบฐ ${timer.phase_name} เบชเบดเปเบเบชเบธเบเปเบฅเปเบง! เบเปเบญเบเบเบฒเบเบชเบทเบเบเปเปเปเบ ${nextDuration} เบเป?`,
          related_id: timerId,
          related_type: 'timer',
          is_urgent: true,
          expires_at: moment().add(24, 'hours').toDate()
        }),
        this.createNotification({
          user_id: timer.user2_id,
          type: 'decision_required',
          title: '๐ เปเบงเบฅเบฒเบเบฑเบเบชเบดเบเปเบ!',
          message: `เปเบฅเบเบฐ ${timer.phase_name} เบชเบดเปเบเบชเบธเบเปเบฅเปเบง! เบเปเบญเบเบเบฒเบเบชเบทเบเบเปเปเปเบ ${nextDuration} เบเป?`,
          related_id: timerId,
          related_type: 'timer',
          is_urgent: true,
          expires_at: moment().add(24, 'hours').toDate()
        })
      ]);

      return notifications;
    } catch (error) {
      console.error('โ Error creating decision required:', error);
    }
  }

  // เบเบถเบ notifications เบเบญเบ user
  static async getUserNotifications(userId, limit = 20) {
    try {
      const notifications = await Notification.findAll({
        where: { user_id: userId },
        order: [['created_at', 'DESC']],
        limit,
        include: [{
          model: User,
          as: 'user',
          attributes: ['username', 'first_name', 'last_name']
        }]
      });

      return notifications;
    } catch (error) {
      console.error('โ Error getting notifications:', error);
      return [];
    }
  }

  // เบเบณเบเบงเบ notifications เบเบตเปเบเบฑเบเบเปเปเปเบเปเบญเปเบฒเบ
  static async getUnreadCount(userId) {
    try {
      const count = await Notification.count({
        where: { 
          user_id: userId, 
          is_read: false 
        }
      });
      return count;
    } catch (error) {
      console.error('โ Error getting unread count:', error);
      return 0;
    }
  }

  // เบกเบฒเบ notification เบงเปเบฒเบญเปเบฒเบเปเบฅเปเบง
  static async markAsRead(notificationId, userId) {
    try {
      const result = await Notification.update(
        { 
          is_read: true, 
          read_at: new Date() 
        },
        { 
          where: { 
            notification_id: notificationId, 
            user_id: userId 
          } 
        }
      );
      return result[0] > 0;
    } catch (error) {
      console.error('โ Error marking as read:', error);
      return false;
    }
  }

  // Helper: เบเบถเบเปเบฅเบเบฐเปเบงเบฅเบฒเบเบญเบ phase เบเปเปเปเบ
  static getNextPhaseDuration(phaseNumber) {
    const phases = {
      2: '7 เบงเบฑเบ',
      3: '31 เบงเบฑเบ', 
      4: '1 เบเบต'
    };
    return phases[phaseNumber] || 'เปเบฅเบเบฐเบชเบธเบเบเปเบฒเบ';
  }
}

module.exports = NotificationService;

// ==========================================
// services/timerService.js
const { ConversationTimer } = require('../models');
const NotificationService = require('./notificationService');
const moment = require('moment');

class TimerService {
  
  // เบชเปเบฒเบ timer เปเปเป
  static async createTimer(conversationId, user1Id, user2Id, phaseNumber = 1) {
    try {
      const phases = {
        1: { name: '3 เบงเบฑเบ', days: 3 },
        2: { name: '7 เบงเบฑเบ', days: 7 },
        3: { name: '31 เบงเบฑเบ', days: 31 },
        4: { name: '1 เบเบต', days: 365 }
      };

      const phase = phases[phaseNumber];
      const startTime = new Date();
      const endTime = moment(startTime).add(phase.days, 'days').toDate();

      const timer = await ConversationTimer.create({
        conversation_id: conversationId,
        user1_id: user1Id,
        user2_id: user2Id,
        phase_number: phaseNumber,
        phase_name: phase.name,
        duration_days: phase.days,
        starts_at: startTime,
        ends_at: endTime,
        is_active: true
      });

      console.log(`โฐ Timer created: Phase ${phaseNumber} (${phase.name})`);
      
      // เบชเปเบฒเบ notification เปเบซเปเบเบฑเบเบชเบญเบ
      await NotificationService.createNotification({
        user_id: user1Id,
        type: 'timer_warning',
        title: '๐ เปเบฅเบตเปเบกเบชเบปเบเบเบฐเบเบฒเปเบฅเปเบง!',
        message: `เปเบเบปเปเบฒเบกเบตเปเบงเบฅเบฒ ${phase.name} เปเบเบเบฒเบเบฎเบนเปเบเบฑเบเบเบฑเบ!`,
        related_id: timer.timer_id,
        related_type: 'timer'
      });

      await NotificationService.createNotification({
        user_id: user2Id,
        type: 'timer_warning',
        title: '๐ เปเบฅเบตเปเบกเบชเบปเบเบเบฐเบเบฒเปเบฅเปเบง!',
        message: `เปเบเบปเปเบฒเบกเบตเปเบงเบฅเบฒ ${phase.name} เปเบเบเบฒเบเบฎเบนเปเบเบฑเบเบเบฑเบ!`,
        related_id: timer.timer_id,
        related_type: 'timer'
      });

      return timer;
    } catch (error) {
      console.error('โ Error creating timer:', error);
      throw error;
    }
  }

  // เบเบงเบเปเบเบดเปเบ timers เบเบตเปเปเบเปเปเบปเบเปเบงเบฅเบฒ
  static async checkExpiringTimers() {
    try {
      const now = new Date();
      const twelveHoursLater = moment(now).add(12, 'hours').toDate();
      const threeHoursLater = moment(now).add(3, 'hours').toDate();

      // เบซเบฒ timers เบเบตเปเปเบเปเปเบปเบเปเบงเบฅเบฒ
      const expiringTimers = await ConversationTimer.findAll({
        where: {
          is_active: true,
          is_completed: false,
          ends_at: {
            [require('sequelize').Op.between]: [now, twelveHoursLater]
          }
        }
      });

      for (const timer of expiringTimers) {
        const timeLeft = moment(timer.ends_at).diff(now, 'hours');
        
        if (timeLeft <= 12 && timeLeft > 3) {
          await NotificationService.createTimerWarning(timer.timer_id, timeLeft);
        } else if (timeLeft <= 3) {
          await NotificationService.createTimerWarning(timer.timer_id, timeLeft);
        }
      }

      // เบซเบฒ timers เบเบตเปเปเบปเบเปเบงเบฅเบฒเปเบฅเปเบง
      const expiredTimers = await ConversationTimer.findAll({
        where: {
          is_active: true,
          is_completed: false,
          ends_at: {
            [require('sequelize').Op.lt]: now
          }
        }
      });

      for (const timer of expiredTimers) {
        await this.expireTimer(timer.timer_id);
      }

      console.log(`๐ Checked ${expiringTimers.length} expiring, ${expiredTimers.length} expired timers`);
    } catch (error) {
      console.error('โ Error checking timers:', error);
    }
  }

  // เบเบณเปเบซเป timer เปเบปเบเบญเบฒเบเบธ
  static async expireTimer(timerId) {
    try {
      const timer = await ConversationTimer.findByPk(timerId);
      if (!timer) return;

      await timer.update({
        is_active: false,
        is_completed: true,
        completed_at: new Date(),
        result: 'expired'
      });

      // เบชเปเบฒเบ decision required notifications
      await NotificationService.createDecisionRequired(timerId);

      console.log(`โฐ Timer expired: ${timerId}`);
    } catch (error) {
      console.error('โ Error expiring timer:', error);
    }
  }

  // เบเบถเบ active timers เบเบฑเบเปเบปเบ
  static async getActiveTimers() {
    try {
      const timers = await ConversationTimer.findAll({
        where: {
          is_active: true,
          is_completed: false
        },
        order: [['ends_at', 'ASC']]
      });
      return timers;
    } catch (error) {
      console.error('โ Error getting active timers:', error);
      return [];
    }
  }
}

module.exports = TimerService;

// ==========================================
// server.js
require('dotenv').config();
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const cron = require('node-cron');

const db = require('./models');
const NotificationService = require('./services/notificationService');
const TimerService = require('./services/timerService');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Store connected users
const connectedUsers = new Map();

// Socket.io connection
io.on('connection', (socket) => {
  console.log('๐ User connected:', socket.id);

  // User joins with their ID
  socket.on('join', async (userId) => {
    connectedUsers.set(userId, socket.id);
    socket.userId = userId;
    
    // Update user's socket_id in database
    await db.User.update(
      { socket_id: socket.id },
      { where: { user_id: userId } }
    );
    
    console.log(`๐ค User ${userId} joined with socket ${socket.id}`);
    
    // Send unread notifications count
    const unreadCount = await NotificationService.getUnreadCount(userId);
    socket.emit('unreadCount', unreadCount);
  });

  // Mark notification as read
  socket.on('markAsRead', async (data) => {
    const success = await NotificationService.markAsRead(data.notificationId, socket.userId);
    if (success) {
      const unreadCount = await NotificationService.getUnreadCount(socket.userId);
      socket.emit('unreadCount', unreadCount);
      socket.emit('notificationRead', data.notificationId);
    }
  });

  // Get user notifications
  socket.on('getNotifications', async () => {
    if (socket.userId) {
      const notifications = await NotificationService.getUserNotifications(socket.userId);
      socket.emit('notifications', notifications);
    }
  });

  // Disconnect
  socket.on('disconnect', () => {
    if (socket.userId) {
      connectedUsers.delete(socket.userId);
      console.log(`๐ค User ${socket.userId} disconnected`);
    }
  });
});

// API Routes
// เบเบถเบ notifications
app.get('/api/notifications/:userId', async (req, res) => {
  try {
    const notifications = await NotificationService.getUserNotifications(req.params.userId);
    res.json(notifications);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// เบชเปเบฒเบ notification เบเบปเบเบชเบญเบ
app.post('/api/test-notification', async (req, res) => {
  try {
    const { userId, type, title, message } = req.body;
    
    const notification = await NotificationService.createNotification({
      user_id: userId,
      type: type || 'timer_warning',
      title: title || 'เบเบฒเบเบเบปเบเบชเบญเบ',
      message: message || 'เบเบตเปเปเบกเปเบ notification เบเบปเบเบชเบญเบ'
    });

    // เบชเบปเปเบ notification เบเปเบฒเบ socket เบเปเบฒ user online
    const socketId = connectedUsers.get(parseInt(userId));
    if (socketId) {
      io.to(socketId).emit('newNotification', notification);
      const unreadCount = await NotificationService.getUnreadCount(userId);
      io.to(socketId).emit('unreadCount', unreadCount);
    }

    res.json({ success: true, notification });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// เบชเปเบฒเบ timer เบเบปเบเบชเบญเบ
app.post('/api/test-timer', async (req, res) => {
  try {
    const { conversationId, user1Id, user2Id, phaseNumber } = req.body;
    
    const timer = await TimerService.createTimer(
      conversationId || 1,
      user1Id || 1,
      user2Id || 2,
      phaseNumber || 1
    );

    res.json({ success: true, timer });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// เบเบถเบ active timers
app.get('/api/timers', async (req, res) => {
  try {
    const timers = await TimerService.getActiveTimers();
    res.json(timers);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve test HTML page
app.get('/', (req, res) => {
  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
        <title>Notification Test</title>
        <script src="/socket.io/socket.io.js"></script>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            .notification { 
                border: 1px solid #ddd; 
                padding: 10px; 
                margin: 5px 0; 
                border-radius: 5px;
                background: #f9f9f9;
            }
            .urgent { border-color: #ff4444; background: #ffe6e6; }
            .unread { font-weight: bold; }
            button { padding: 10px; margin: 5px; }
        </style>
    </head>
    <body>
        <h1>๐ Notification System Test</h1>
        
        <div>
            <label>User ID: <input type="number" id="userId" value="1"></label>
            <button onclick="connectUser()">Connect</button>
            <button onclick="getNotifications()">Get Notifications</button>
        </div>
        
        <div>
            <h3>Test Actions:</h3>
            <button onclick="testNotification()">Send Test Notification</button>
            <button onclick="testTimer()">Create Test Timer</button>
            <button onclick="getTimers()">Get Active Timers</button>
        </div>
        
        <div>
            <h3>Unread Count: <span id="unreadCount">0</span></h3>
        </div>
        
        <div id="notifications"></div>
        
        <script>
            const socket = io();
            let currentUserId = null;
            
            function connectUser() {
                currentUserId = document.getElementById('userId').value;
                socket.emit('join', parseInt(currentUserId));
                console.log('Connected as user:', currentUserId);
            }
            
            function getNotifications() {
                socket.emit('getNotifications');
            }
            
            function testNotification() {
                fetch('/api/test-notification', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: currentUserId,
                        type: 'timer_warning',
                        title: 'โฐ เบเบฒเบเบเบปเบเบชเบญเบ Notification',
                        message: 'เบเบตเปเปเบกเปเบ notification เบเบปเบเบชเบญเบเบเบฒเบ server!'
                    })
                });
            }
            
            function testTimer() {
                fetch('/api/test-timer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversationId: 1,
                        user1Id: 1,
                        user2Id: 2,
                        phaseNumber: 1
                    })
                });
            }
            
            function getTimers() {
                fetch('/api/timers')
                    .then(r => r.json())
                    .then(data => {
                        console.log('Active timers:', data);
                        alert('Check console for timers');
                    });
            }
            
            function markAsRead(notificationId) {
                socket.emit('markAsRead', { notificationId });
            }
            
            // Socket events
            socket.on('unreadCount', (count) => {
                document.getElementById('unreadCount').innerText = count;
            });
            
            socket.on('notifications', (notifications) => {
                const container = document.getElementById('notifications');
                container.innerHTML = '<h3>Notifications:</h3>';
                
                notifications.forEach(notif => {
                    const div = document.createElement('div');
                    div.className = 'notification' + 
                        (notif.is_urgent ? ' urgent' : '') + 
                        (!notif.is_read ? ' unread' : '');
                    
                    div.innerHTML = \`
                        <h4>\${notif.title}</h4>
                        <p>\${notif.message}</p>
                        <small>Type: \${notif.notification_type} | Created: \${new Date(notif.created_at).toLocaleString()}</small>
                        \${!notif.is_read ? \`<button onclick="markAsRead(\${notif.notification_id})">Mark as Read</button>\` : '<span style="color: green;">โ Read</span>'}
                    \`;
                    container.appendChild(div);
                });
            });
            
            socket.on('newNotification', (notification) => {
                console.log('New notification received:', notification);
                getNotifications(); // Refresh notifications
                
                // Show browser notification if supported
                if (Notification.permission === 'granted') {
                    new Notification(notification.title, {
                        body: notification.message,
                        icon: '/favicon.ico'
                    });
                }
            });
            
            socket.on('notificationRead', (notificationId) => {
                console.log('Notification marked as read:', notificationId);
            });
            
            // Request notification permission
            if (Notification.permission === 'default') {
                Notification.requestPermission();
            }
            
            // Auto-connect user 1 on load
            window.onload = () => {
                connectUser();
                getNotifications();
            };
        </script>
    </body>
    </html>
  `);
});

// Cron job - เบเบงเบเปเบเบดเปเบ timers เบเบธเบเป 5 เบเบฒเบเบต
cron.schedule('*/5 * * * *', async () => {
  console.log('๐ Running timer check...');
  await TimerService.checkExpiringTimers();
});

// Helper function to send notification to user
async function sendNotificationToUser(userId, notification) {
  const socketId = connectedUsers.get(parseInt(userId));
  if (socketId) {
    io.to(socketId).emit('newNotification', notification);
    const unreadCount = await NotificationService.getUnreadCount(userId);
    io.to(socketId).emit('unreadCount', unreadCount);
    console.log(`๐ค Notification sent to user ${userId}`);
  } else {
    console.log(`๐ด User ${userId} is offline`);
  }
}

// Initialize database and start server
async function startServer() {
  try {
    // Test database connection
    await db.sequelize.authenticate();
    console.log('โ Database connected successfully');
    
    // Sync database (creates tables if they don't exist)
    await db.sequelize.sync({ force: false }); // Set to true to recreate tables
    console.log('โ Database synced');
    
    // Create test users if they don't exist
    const users = await db.User.findAll();
    if (users.length === 0) {
      await db.User.bulkCreate([
        {
          username: 'testuser1',
          email: 'user1@test.com',
          first_name: 'User',
          last_name: 'One'
        },
        {
          username: 'testuser2',
          email: 'user2@test.com',
          first_name: 'User',
          last_name: 'Two'
        }
      ]);
      console.log('โ Test users created');
    }
    
    const PORT = process.env.PORT || 3000;
    server.listen(PORT, () => {
      console.log(`๐ Server running on port ${PORT}`);
      console.log(`๐ Open http://localhost:${PORT} to test notifications`);
    });
    
  } catch (error) {
    console.error('โ Unable to start server:', error);
  }
}

// ==========================================
// migrations/001-create-users.js
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('users', {
      user_id: {
        type: Sequelize.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      username: {
        type: Sequelize.STRING(50),
        allowNull: false,
        unique: true
      },
      email: {
        type: Sequelize.STRING(100),
        allowNull: false,
        unique: true
      },
      first_name: {
        type: Sequelize.STRING(50),
        allowNull: false
      },
      last_name: {
        type: Sequelize.STRING(50),
        allowNull: false
      },
      is_active: {
        type: Sequelize.BOOLEAN,
        defaultValue: true
      },
      socket_id: {
        type: Sequelize.STRING(100),
        allowNull: true
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW
      }
    });

    // Add indexes for PostgreSQL
    await queryInterface.addIndex('users', ['username']);
    await queryInterface.addIndex('users', ['email']);
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('users');
  }
};

// ==========================================
// migrations/002-create-notifications.js
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('notifications', {
      notification_id: {
        type: Sequelize.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      user_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'users',
          key: 'user_id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      notification_type: {
        type: Sequelize.ENUM(
          'timer_warning', 
          'timer_expired', 
          'decision_required', 
          'partner_decision',
          'match_found',
          'message_received'
        ),
        allowNull: false
      },
      title: {
        type: Sequelize.STRING(200),
        allowNull: false
      },
      message: {
        type: Sequelize.TEXT,
        allowNull: false
      },
      related_id: {
        type: Sequelize.INTEGER,
        allowNull: true
      },
      related_type: {
        type: Sequelize.ENUM('timer', 'conversation', 'match', 'message'),
        allowNull: true
      },
      is_read: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      is_urgent: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      scheduled_at: {
        type: Sequelize.DATE,
        allowNull: true
      },
      sent_at: {
        type: Sequelize.DATE,
        allowNull: true
      },
      read_at: {
        type: Sequelize.DATE,
        allowNull: true
      },
      expires_at: {
        type: Sequelize.DATE,
        allowNull: true
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW
      }
    });

    // Add indexes
    await queryInterface.addIndex('notifications', ['user_id']);
    await queryInterface.addIndex('notifications', ['is_read']);
    await queryInterface.addIndex('notifications', ['notification_type']);
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('notifications');
  }
};

// ==========================================
// migrations/003-create-conversation-timers.js
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('conversation_timers', {
      timer_id: {
        type: Sequelize.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      conversation_id: {
        type: Sequelize.INTEGER,
        allowNull: false
      },
      user1_id: {
        type: Sequelize.INTEGER,
        allowNull: false
      },
      user2_id: {
        type: Sequelize.INTEGER,
        allowNull: false
      },
      phase_number: {
        type: Sequelize.INTEGER,
        allowNull: false,
        defaultValue: 1
      },
      phase_name: {
        type: Sequelize.STRING(50),
        allowNull: false
      },
      duration_days: {
        type: Sequelize.INTEGER,
        allowNull: false
      },
      starts_at: {
        type: Sequelize.DATE,
        allowNull: false
      },
      ends_at: {
        type: Sequelize.DATE,
        allowNull: false
      },
      is_active: {
        type: Sequelize.BOOLEAN,
        defaultValue: true
      },
      is_completed: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      completed_at: {
        type: Sequelize.DATE,
        allowNull: true
      },
      result: {
        type: Sequelize.ENUM('both_continue', 'user1_stop', 'user2_stop', 'expired'),
        allowNull: true
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW
      }
    });

    // Add indexes
    await queryInterface.addIndex('conversation_timers', ['conversation_id']);
    await queryInterface.addIndex('conversation_timers', ['is_active']);
    await queryInterface.addIndex('conversation_timers', ['ends_at']);
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('conversation_timers');
  }
};

// ==========================================
// .sequelizerc
const path = require('path');

module.exports = {
  'config': path.resolve('config', 'database.js'),
  'models-path': path.resolve('models'),
  'seeders-path': path.resolve('seeders'),
  'migrations-path': path.resolve('migrations')
};

// ==========================================
// README.md
# ๐ Notification System for Love App

## เบเบณเบญเบฐเบเบดเบเบฒเบ (Description)
เบฅเบฐเบเบปเบ Notification เบชเบณเบฅเบฑเบ Dating App เบเบตเปเบกเบต real-time notifications, countdown timers, เปเบฅเบฐ automatic scheduling.

## ๐ เบเบฒเบเบเบดเบเบเบฑเปเบ (Installation)

### 1. Clone project
\`\`\`bash
mkdir notification-system
cd notification-system
\`\`\`

### 2. เบเบดเบเบเบฑเปเบ dependencies
\`\`\`bash
npm install
\`\`\`

### 3. เบชเปเบฒเบ database
\`\`\`sql
CREATE DATABASE notification_test;
\`\`\`

### 4. เปเบเปเปเบ .env file
\`\`\`env
NODE_ENV=development
PORT=3000
DB_HOST=localhost
DB_PORT=3306
DB_NAME=notification_test
DB_USER=root
DB_PASS=your_password
\`\`\`

### 5. Run migrations
\`\`\`bash
npx sequelize-cli db:migrate
\`\`\`

### 6. Start server
\`\`\`bash
npm run dev
\`\`\`

### 7. เปเบเบตเบเปเบ browser
\`\`\`
http://localhost:3000
\`\`\`

## ๐ฏ เบเบตเปเบเบตเบเบตเปเบเบปเบเบชเบญเบเปเบเป (Features to Test)

### โ Real-time Notifications
- เบชเบปเปเบ notification เปเบเบ real-time
- เบเบฑเบเบเบณเบเบงเบ unread notifications
- Mark as read functionality

### โฐ Timer System
- เบชเปเบฒเบ countdown timers เบชเบณเบฅเบฑเบเปเบเปเบฅเบฐเปเบฅเบเบฐ
- เบเบงเบเปเบเบดเปเบ timers เบเบตเปเปเบเปเปเบปเบเปเบงเบฅเบฒ
- Auto-expire timers

### ๐ Automatic Scheduling
- Cron job เบเบธเบเป 5 เบเบฒเบเบต
- เปเบเปเบเปเบเบทเบญเบเบเปเบญเบเปเบปเบเปเบงเบฅเบฒ 12 เบเบปเปเบงเปเบกเบ เปเบฅเบฐ 3 เบเบปเปเบงเปเบกเบ

## ๐ฑ เบเบฒเบเบเบปเบเบชเบญเบ (Testing)

### 1. เปเบเบตเบ browser 2 tabs
- Tab 1: User ID = 1  
- Tab 2: User ID = 2

### 2. เบเบปเบเบชเบญเบ notifications
- Click "Send Test Notification"
- เปเบเบดเปเบ notification เบเบฐเบเบปเบเปเบเบ real-time

### 3. เบเบปเบเบชเบญเบ timers
- Click "Create Test Timer" 
- เปเบเบดเปเบ countdown เปเบฅเบฐ notifications

### 4. เบเบปเบเบชเบญเบ mark as read
- Click "Mark as Read"
- เปเบเบดเปเบ unread count เบซเบผเบธเบเบฅเบปเบ

## ๐๏ธ เปเบเบเบชเปเบฒเบ Project

\`\`\`
notification-system/
โโโ config/
โ   โโโ database.js          # Database configuration
โโโ migrations/
โ   โโโ 001-create-users.js
โ   โโโ 002-create-notifications.js
โ   โโโ 003-create-conversation-timers.js
โโโ models/
โ   โโโ index.js            # Database connection
โ   โโโ User.js             # User model
โ   โโโ Notification.js     # Notification model
โ   โโโ ConversationTimer.js # Timer model
โโโ services/
โ   โโโ notificationService.js # Notification logic
โ   โโโ timerService.js     # Timer logic
โโโ .env                    # Environment variables
โโโ .sequelizerc           # Sequelize configuration
โโโ package.json
โโโ server.js              # Main server file
\`\`\`

## ๐ง API Endpoints

### GET /api/notifications/:userId
เบเบถเบ notifications เบเบญเบ user

### POST /api/test-notification
เบชเปเบฒเบ test notification
\`\`\`json
{
  "userId": 1,
  "type": "timer_warning",
  "title": "Test Title",
  "message": "Test Message"
}
\`\`\`

### POST /api/test-timer
เบชเปเบฒเบ test timer
\`\`\`json
{
  "conversationId": 1,
  "user1Id": 1,
  "user2Id": 2,
  "phaseNumber": 1
}
\`\`\`

### GET /api/timers
เบเบถเบ active timers เบเบฑเบเปเบปเบ

## ๐ฎ Socket Events

### Client to Server:
- \`join\` - User connects with ID
- \`getNotifications\` - Request notifications
- \`markAsRead\` - Mark notification as read

### Server to Client:
- \`newNotification\` - New notification received
- \`unreadCount\` - Updated unread count
- \`notifications\` - List of notifications
- \`notificationRead\` - Notification marked as read

## ๐ Timer Phases
1. **Phase 1**: 3 เบงเบฑเบ (เปเบฅเบตเปเบกเบเบปเปเบ)
2. **Phase 2**: 7 เบงเบฑเบ (เบเปเบฒเบเบฑเบเบชเบญเบเบชเบทเบเบเปเป)
3. **Phase 3**: 31 เบงเบฑเบ (เบเปเบฒเบเบฑเบเบชเบญเบเบชเบทเบเบเปเป)
4. **Phase 4**: 1 เบเบต (เปเบฅเบเบฐเบชเบธเบเบเปเบฒเบ)

## ๐จ Notification Types
- \`timer_warning\` - เปเบงเบฅเบฒเปเบเปเปเบปเบ
- \`timer_expired\` - เปเบงเบฅเบฒเปเบปเบเปเบฅเปเบง
- \`decision_required\` - เบเปเบญเบเบเบฑเบเบชเบดเบเปเบ
- \`partner_decision\` - เบเบนเปเบเบฑเบเบชเบดเบเปเบเปเบฅเปเบง
- \`match_found\` - เบเบปเบเบเบนเปเปเปเป
- \`message_received\` - เปเบเปเบฎเบฑเบเบเปเปเบเบงเบฒเบก

เบฅเบฐเบเบปเบเบเบตเปเบเปเบญเบกเปเบเปเบเบฒเบเปเบฅเปเบง! ๐